/*
Copyright (c) Uber Technologies, Inc.

This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.
*/
// @flow

import * as React from 'react';

export type ConfigurationOverrideFunctionT = ({}) => ?{};
export type ConfigurationOverrideObjectT = {};

export type ConfigurationOverrideT = ConfigurationOverrideObjectT | ConfigurationOverrideFunctionT;

export type StyleOverrideT = ConfigurationOverrideT;

export type OverrideObjectT = {|
  // flowlint-next-line unclear-type:off
  component?: ?React.ComponentType<any>,
  props?: ?ConfigurationOverrideT,
  style?: ?ConfigurationOverrideT,
|};

// flowlint-next-line unclear-type:off
export type OverrideT = OverrideObjectT | React.ComponentType<any>;

export type OverridesT = {
  [string]: OverrideT,
};

/**
 * Given an override argument, returns the component implementation override if it exists
 */
// flowlint-next-line unclear-type:off
declare export function getOverride(override: any): any;

/**
 * Given an override argument, returns the override props that should be passed
 * to the component when rendering it.
 */
declare export function getOverrideProps<T>(override: ?OverrideT): T;

/**
 * Coerces an override argument into an override object
 * (sometimes it is just an override component)
 */
declare export function toObjectOverride<T>(override: OverrideT): OverrideObjectT;

/**
 * Get a convenient override array that will always have [component, props]
 */
// flowlint unclear-type:off
declare export function getOverrides<T>(
  override: Object,
  defaultComponent: React.ComponentType<any>
): [React.ComponentType<any>, T];
/* flowlint unclear-type:error */

/**
 * Merges two overrides objects â€“ this is useful if you want to inject your own
 * overrides into a child component, but also accept further overrides from
 * from upstream. See `mergeOverride` below.
 */
declare export function mergeOverrides(target?: OverridesT, source?: OverridesT): OverridesT;

/**
 * Merges two override objects using the following behavior:
 * - Component implementation from the source (parent) replaces target
 * - Props and styles are both deep merged
 */
declare export function mergeOverride(
  target: OverrideObjectT,
  source: OverrideObjectT
): OverrideObjectT;

/**
 * Since style or props overrides can be an object *or* a function, we need to handle
 * the case that one of them is a function. We do this by returning a new
 * function that deep merges the result of each style override
 */
declare export function mergeConfigurationOverrides(
  target: ConfigurationOverrideT,
  source: ConfigurationOverrideT
): ConfigurationOverrideT;

// Lil' hook for memoized unpacking of overrides
// flowlint unclear-type:off
declare export function useOverrides(
  defaults: {
    [string]: React.ComponentType<any>,
  },
  overrides?: OverridesT
): { [string]: [React.ComponentType<any>, {}] };
